use handlebars::{
    Context, Handlebars, Helper, HelperResult, Output, RenderContext, handlebars_helper,
};
use serde_json::Value;

// Define helper using macro outside function
handlebars_helper!(HandlebarsEq: |x: Value, y: Value| x == y);

pub fn apply_template(template: &str, json: &serde_json::Value) -> String {
    let mut reg = Handlebars::new();
    reg.set_strict_mode(false);

    // Register built-in helpers
    reg.register_helper(
        "json",
        Box::new(
            |h: &Helper,
             _: &Handlebars,
             _: &Context,
             _: &mut RenderContext,
             out: &mut dyn Output|
             -> HelperResult {
                let param =
                    h.param(0)
                        .ok_or(handlebars::RenderErrorReason::ParamNotFoundForIndex(
                            "json", 0,
                        ))?;
                let json_str = serde_json::to_string(param.value())
                    .map_err(|e| handlebars::RenderErrorReason::Other(e.to_string()))?;
                out.write(&json_str)?;
                Ok(())
            },
        ),
    );

    // Register EQ helper generated by macro
    reg.register_helper("eq", Box::new(HandlebarsEq));

    // Helper: {{is_string var}} -> boolean
    reg.register_helper(
        "is_string",
        Box::new(
            |h: &Helper,
             _: &Handlebars,
             _: &Context,
             _: &mut RenderContext,
             out: &mut dyn Output|
             -> HelperResult {
                let param =
                    h.param(0)
                        .ok_or(handlebars::RenderErrorReason::ParamNotFoundForIndex(
                            "is_string",
                            0,
                        ))?;
                if param.value().is_string() {
                    out.write("true")?;
                }
                Ok(())
            },
        ),
    );

    // Helper: {{is_array var}} -> boolean
    reg.register_helper(
        "is_array",
        Box::new(
            |h: &Helper,
             _: &Handlebars,
             _: &Context,
             _: &mut RenderContext,
             out: &mut dyn Output|
             -> HelperResult {
                let param =
                    h.param(0)
                        .ok_or(handlebars::RenderErrorReason::ParamNotFoundForIndex(
                            "is_array", 0,
                        ))?;
                if param.value().is_array() {
                    out.write("true")?;
                }
                Ok(())
            },
        ),
    );

    reg.render_template(template, json)
        .unwrap_or_else(|e| format!("Template Error: {}", e))
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_apply_template_simple() {
        let template = r#"{"msg": "{{text}}", "channel": "{{chan}}"}"#;
        let input = serde_json::json!({
            "text": "Hello World",
            "chan": "general"
        });

        let result_str = apply_template(template, &input);

        assert_eq!(
            result_str,
            r#"{"msg": "Hello World", "channel": "general"}"#
        );
    }

    #[test]
    fn test_apply_template_handlebars() {
        let template = r#"{
            "system": {
                "parts": [ { "text": {{json system_instruction}} } ]
            },
            "is_user": {{#if (eq role "user")}}true{{else}}false{{/if}}
        }"#;

        let input = serde_json::json!({
            "system_instruction": "Be helpful.",
            "role": "user"
        });

        let result_str = apply_template(template, &input);

        let parsed: serde_json::Value =
            serde_json::from_str(&result_str).expect("Result should be valid JSON");
        assert_eq!(parsed["system"]["parts"][0]["text"], "Be helpful.");
        assert_eq!(parsed["is_user"], true);

        let input2 = serde_json::json!({
            "system_instruction": "ignore",
            "role": "model"
        });
        let result_str2 = apply_template(template, &input2);
        let parsed2: serde_json::Value =
            serde_json::from_str(&result_str2).expect("Result should be valid JSON");
        assert_eq!(parsed2["is_user"], false);
    }

    #[test]
    fn test_apply_template_gemini_advanced() {
        let template = r#"{
            "contents": [
                {{#each messages}}
                {
                    "role": "{{#if (eq role "user")}}user{{else}}model{{/if}}",
                    "parts": [
                        {{#if (is_string content)}}
                        { "text": {{json content}} }
                        {{else if (is_array content)}}
                        {{#each content}}{{json this}}{{#unless @last}},{{/unless}}{{/each}}
                        {{/if}}
                    ]
                }{{#unless @last}},{{/unless}}
                {{/each}}
            ],
            {{#if tools}}
            "tools": [{"function_declarations": {{json tools}}}],
            "tool_config": { "function_calling_config": { "mode": "{{#if (eq tool_choice "Required")}}ANY{{else}}AUTO{{/if}}" } }
            {{/if}}
        }"#;

        let input = json!({
            "messages": [
                { "role": "user", "content": "Hello" },
                { "role": "assistant", "content": [ { "text": "Hi" }, { "thought": "Thinking..." } ] }
            ],
            "tools": [ { "name": "test", "description": "desc", "parameters": {} } ],
            "tool_choice": "Auto"
        });

        let result_str = apply_template(template, &input);
        let parsed: serde_json::Value =
            serde_json::from_str(&result_str).expect("Valid JSON expected");

        assert_eq!(parsed["contents"][0]["role"], "user");
        assert_eq!(parsed["contents"][1]["role"], "model");
        assert_eq!(parsed["contents"][0]["parts"][0]["text"], "Hello");
        assert_eq!(parsed["contents"][1]["parts"][0]["text"], "Hi");
        assert_eq!(parsed["contents"][1]["parts"][1]["thought"], "Thinking...");

        assert_eq!(
            parsed["tools"][0]["function_declarations"][0]["name"],
            "test"
        );
        assert_eq!(
            parsed["tool_config"]["function_calling_config"]["mode"],
            "AUTO"
        );
    }
}
